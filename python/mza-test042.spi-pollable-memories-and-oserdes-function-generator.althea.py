#!/usr/bin/env python

# written 2020-05-11 by mza
# based on mza-test041.spi-pollable-memory.althea.py
# last updated 2020-05-23 by mza

import time # time.sleep
from generic import * # hex, eng
import althea

althea.reset()
spi_ce0 = althea.spi(0, 16)
spi_ce1 = althea.spi(1, 4096)

import os # os.path.isfile
import re # re.search

RF_buckets = 5120
# borrowed from xrm.py in uh-svn-repo; reads from csv files generated by xrm.py
def read_bcm_csv(input_filename, date_string):
	print "loading bcm timeseries from file..."
	scaling = 2
	values = []
	if os.path.isfile(input_filename):
		input_file = open(input_filename)
		lines = input_file.readlines()
		for line in lines:
			match = re.search("^" + date_string + ",(.*)", line)
			if match:
				valuestring = match.group(1)
				values = re.split(r',', valuestring)
				count = len(values)
				if not count==scaling*RF_buckets:
					#warning("read in " + str(count) + " datapoints")
					pass
	else:
		print "can't open file \"" + input_filename + "\""
		sys.exit(1)
	return values

def normalize_bcm_data(values, max_for_normalization):
	max_value = 0
	if len(values)==0:
		#warning("no data found in file")
		return
	for i in range(len(values)):
		values[i] = int(values[i])
		max_value = max(max_value, values[i])
	#info("max_value: " + str(max_value))
	if max_value==0:
		#warning("no data found in file")
		return
	normalization = max_for_normalization / max_value
	#info("normalization: " + str(normalization))
	for i in range(len(values)):
		values[i] = int(values[i]*normalization)
	return values

def write_bcm_values_to_spi_pollable_memory_and_verify(spi, length, offset, input_filename, date_string, max_for_normalization=6.0):
	offset = int(offset/16.0)
	max_for_normalization = float(max_for_normalization)
	command_list = [ c for c in range(length) ]
	address_list = [ offset+a for a in range(length) ]
	data_list = [ 0 for d in range(length) ]
	if 1:
		bcm_list = read_bcm_csv(input_filename, date_string)
		bcm_list = normalize_bcm_data(bcm_list, max_for_normalization)
	else:
		bcm_list = [ 
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1  ]
	# bcm_list has an integer entry for each RF_bucket as a time series
	# data_list has an entry for each group of 32 RF_buckets
	k = 0
	value_low = 0
	for i in range(0, len(bcm_list), 32):
		value = value_low<<32
		for j in range(32):
			if bcm_list[i+j]:
				#pulse_width = 2
				pulse_width = bcm_list[i+j]
				index = 31-j-pulse_width+32 # fill the high part of a 64-bit word
				value |= (2**pulse_width-1)<<index
		#print hex(value, 8)
		value_low = value & 0xffffffff # save what spilled over into the low 32 bits for next time
		value_high = value - value_low
		data_list[k] = value_high>>32
		k += 1
	#print k
	#print len(data_list)
	if len(data_list)<length:
		for i in range(len(data_list), length):
			data_list.append(0)
#	for i in range(length):
#		if i<64:
#			data_list[i] = 0
#	print len(data_list)
	print "uploading bcm timeseries to device..."
	spi.write_list_to_pollable_memory_and_then_verify(length, command_list, address_list, data_list)

#test_command8_address16_data32(spi_ce0, 2**4, 40)
#test_command8_address16_data32(spi_ce1, 2**12, 10)

#write_zero_values_to_spi_pollable_memory_and_verify(spi_ce1, 2**12)
spi_ce1.write_zero_values_to_spi_pollable_memory_and_verify(2**12)
#write_values_to_spi_pollable_memory_and_verify(spi_ce0, 2, [ 0, 16 ])
#write_values_to_spi_pollable_memory_and_verify(spi_ce0, 2, [ 0, 9.0*RF_buckets ])
spi_ce0.write_values_to_spi_pollable_memory_and_verify(2, [ 11*RF_buckets, 12*RF_buckets ])

# 10240 samples per revolution
# 1 address per 8 samples
# 10240/8=1280 addresses per revolution
# 9*10240/8=9*1280 addresses per revo9
# updated firmware so that the start/end limits are in units of RF_buckets
# but keep in mind that the 2 least significant bits are discarded
#write_values_to_spi_pollable_memory_and_verify(spi_ce0, 2**4, [ 0, 1*RF_buckets ])
#write_values_to_spi_pollable_memory_and_verify(spi_ce0, 2**4, [ 0.5*RF_buckets, 3.2*RF_buckets ])
#write_values_to_spi_pollable_memory_and_verify(spi_ce0, 2**4, [ 0, 9*RF_buckets ])
if 0:
	while True:
		for i in range(0, 640, 16):
			j = i + 640
			#for j in range(640, 1280, 16):
			#	print str(i) + "," + str(j)
			spi_ce0.write_values_to_spi_pollable_memory_and_verify(2, [ i, j ])
			time.sleep(0.01)

#write_values_to_spi_pollable_memory_and_verify(spi_ce0, 2**4, [ 4079, 4095 ])

#write_pseudorandom_values_to_spi_pollable_memory_and_verify(spi_ce1, 2**12)
#write_zero_values_to_spi_pollable_memory_and_verify(spi_ce1, 2**12)
#write_sequential_values_to_spi_pollable_memory_and_verify(spi_ce1, 2**12)
#write_zero_values_to_spi_pollable_memory_and_verify(spi_ce1, 2**12, 32)

date_string = "2019-11-15.075530"
#size = RF_buckets/16
#size = 2**12
size = 0x140
#size = 0x280
#size = 0x500
#size = 0xa00
for i in range(9):
#for i in range(8, -1, -1):
#for i in range(7, 6, -1):
	write_bcm_values_to_spi_pollable_memory_and_verify(spi_ce1, size, i*RF_buckets, "bcm.csv", date_string, i)
	time.sleep(0.1)

spi_ce0.write_values_to_spi_pollable_memory_and_verify(2, [ 0, 9.0*RF_buckets ]) # revo9 periodic
#write_values_to_spi_pollable_memory_and_verify(spi_ce0, 2, [ 0, 12.7*RF_buckets ]) # whole memory

def cycle():
	print "cycling..."
	i = 0
	while True:
		j = i % 9
		k = (i + 1) % 9
		if 0==k:
			k = 9
		#print str(j) + " " + str(k)
		spi_ce0.write_values_to_spi_pollable_memory_and_verify(2, [ j*RF_buckets, k*RF_buckets ])
		i += 1
		time.sleep(0.001)

#cycle()

spi_ce0.write_values_to_spi_pollable_memory_and_verify(2, [ 2, 0 ], 2) # test idelay inc/dec functionality

